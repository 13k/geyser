package main

import (
	"fmt"
	"path/filepath"
	"strings"

	"github.com/13k/geyser"
	j "github.com/dave/jennifer/jen"
	"github.com/huandu/xstrings"
)

const (
	pkgPathGeyser = "github.com/13k/geyser"

	srcPkgNetHTTP             = "net/http"
	srcPkgGeyser              = "geyser"
	srcSchemaInterfacesCtor   = "MustNewSchemaInterfaces"
	srcSchemaInterface        = "SchemaInterface"
	srcSchemaMethodsCtor      = "MustNewSchemaMethods"
	srcSchemaMethod           = "SchemaMethod"
	srcSchemaMethodParamsCtor = "NewSchemaMethodParams"
	srcSchemaMethodParam      = "SchemaMethodParam"
	srcClient                 = "Client"
	srcRequest                = "Request"

	commentDisclaimer           = "Code generated by github.com/13k/geyser/apigen. DO NOT EDIT."
	commentfDisclaimerInterface = "API interface: %s."
	commentfSchemaVar           = "%s stores the SchemaInterfaces for interface %s."
	commentfStruct              = "%s represents interface %s."
	commentfSupportedAppIDs     = "Supported AppIDs: %d."
	commentfSupportedVersions   = "Supported versions: %d."
	commentfStructCtor          = "%s creates a new %s interface."
	commentfStructGetter        = "%s creates a new %s interface."
	commentfStructMethodHeader  = "%s creates a Request for interface method %s."
	commentfStructResult        = "%s holds the result of the method %s/%s."

	errfUnknownInterfaceFilename = "Unknown filename for interface %q"
	errfUnknownHTTPMethod        = "Unknown HTTP method %q of interface method %q/%q"
)

type APIGen struct {
	baseName       string
	interfaces     *geyser.SchemaInterfaces
	groupedMethods map[string]*geyser.SchemaMethods
	appIDs         []uint32
	requiredAppID  bool
	externalPkg    bool
	pkgName        string
	schemaVarName  string
	structName     string
	structCtorName string
	interfaceFile  *GeneratedFile
	resultsFile    *GeneratedFile
}

func NewAPIGen(
	sis *geyser.SchemaInterfaces,
	pkgName string,
	outputDir string,
	filenames map[string]string,
) (*APIGen, error) {
	baseName, err := sis.GroupName()

	if err != nil {
		return nil, err
	}

	appIDs, err := sis.AppIDs()

	if err != nil {
		return nil, err
	}

	groupedMethods, err := sis.GroupMethods()

	if err != nil {
		return nil, err
	}

	baseFilename := filenames[baseName]

	if baseFilename == "" {
		err = fmt.Errorf(errfUnknownInterfaceFilename, baseName)
		return nil, err
	}

	structName := strings.TrimPrefix(baseName, "I")
	structCtorName := "New" + structName
	schemaVarName := "Schema" + structName
	interfaceFile := NewGeneratedFile(filepath.Join(outputDir, baseFilename+".go"))
	resultsFile := NewGeneratedFile(filepath.Join(outputDir, baseFilename+"_results.go"))

	g := &APIGen{
		baseName:       baseName,
		interfaces:     sis,
		groupedMethods: groupedMethods,
		appIDs:         appIDs,
		requiredAppID:  len(appIDs) > 0,
		externalPkg:    pkgName != srcPkgGeyser,
		pkgName:        pkgName,
		structName:     structName,
		structCtorName: structCtorName,
		schemaVarName:  schemaVarName,
		interfaceFile:  interfaceFile,
		resultsFile:    resultsFile,
	}

	return g, nil
}

func (g *APIGen) genSIDecl(si *geyser.SchemaInterface) (j.Code, error) {
	var methodDecls []j.Code

	for _, sm := range si.GetMethods() {
		methodDecl, err := g.genSMDecl(si, sm)

		if err != nil {
			return nil, err
		}

		methodDecls = append(methodDecls, j.Line().Add(methodDecl))
	}

	methodDecls = append(methodDecls, j.Line())
	methodsDecl := g.jenSchemaMethodsCtorID().Call(methodDecls...)

	code := g.jenSchemaInterfaceAddr().Values(j.Dict{
		j.Id("Name"):         j.Lit(si.Name),
		j.Id("Methods"):      methodsDecl,
		j.Id("Undocumented"): j.Lit(si.Undocumented),
	})

	return code, nil
}

func (g *APIGen) genSMDecl(si *geyser.SchemaInterface, sm *geyser.SchemaMethod) (j.Code, error) {
	httpMethod := jenHTTPMethod(sm.HTTPMethod)

	if httpMethod == nil {
		err := fmt.Errorf(errfUnknownHTTPMethod, sm.HTTPMethod, si.Name, sm.Name)
		return nil, err
	}

	var paramDecls []j.Code

	for _, smp := range sm.GetParams() {
		paramDecl := g.genSMPDecl(si, sm, smp)
		paramDecls = append(paramDecls, j.Line().Add(paramDecl))
	}

	paramDecls = append(paramDecls, j.Line())
	paramsSliceDecl := g.jenSchemaMethodParamsCtor().Call(paramDecls...)

	code := g.jenSchemaMethodAddr().Values(j.Dict{
		j.Id("Name"):         j.Lit(sm.Name),
		j.Id("Version"):      j.Lit(sm.Version),
		j.Id("HTTPMethod"):   httpMethod,
		j.Id("Params"):       paramsSliceDecl,
		j.Id("Undocumented"): j.Lit(sm.Undocumented),
	})

	return code, nil
}

func (g *APIGen) genSMPDecl(
	_ *geyser.SchemaInterface,
	_ *geyser.SchemaMethod,
	smp *geyser.SchemaMethodParam,
) j.Code {
	return g.jenSchemaMethodParamAddr().Values(j.Dict{
		j.Id("Name"):        j.Lit(smp.Name),
		j.Id("Type"):        j.Lit(smp.Type),
		j.Id("Optional"):    j.Lit(smp.Optional),
		j.Id("Description"): j.Lit(smp.Description),
	})
}

func (g *APIGen) genSchemaDecl() (j.Code, error) {
	var siDecls []j.Code

	for _, si := range g.interfaces.Interfaces {
		siDecl, err := g.genSIDecl(si)

		if err != nil {
			return nil, err
		}

		siDecls = append(siDecls, j.Line().Add(siDecl))
	}

	siDecls = append(siDecls, j.Line())
	comment := fmt.Sprintf(commentfSchemaVar, g.schemaVarName, g.baseName)

	schemaDecl := j.
		Comment(comment).
		Line().
		Var().
		Id(g.schemaVarName).
		Op("=").
		Add(g.jenSchemaInterfacesCtorID()).
		Call(siDecls...)

	return schemaDecl, nil
}

func (g *APIGen) genStructDef() j.Code {
	comments := []string{
		fmt.Sprintf(commentfStruct, g.structName, g.baseName),
	}

	if g.requiredAppID {
		comments = append(comments, fmt.Sprintf(commentfSupportedAppIDs, g.appIDs))
	}

	fields := []j.Code{
		j.Id("Client").Add(g.jenUnqualiClientPtr()),
		j.Id("Interface").Add(g.jenSchemaInterfacePtr()),
	}

	code := j.Null()

	for i, c := range comments {
		code.Comment(c).Line()

		if i != len(comments)-1 {
			code.Comment("").Line()
		}
	}

	return code.Type().Id(g.structName).Struct(fields...)
}

func (g *APIGen) genStructCtor() j.Code {
	comments := []string{
		fmt.Sprintf(commentfStructCtor, g.structCtorName, g.structName),
	}

	params := []j.Code{
		j.Id("c").Add(g.jenUnqualiClientPtr()),
	}

	if g.requiredAppID {
		params = append(params, j.Id("appID").Uint32())
		comments = append(comments, fmt.Sprintf(commentfSupportedAppIDs, g.appIDs))
	}

	retTypes := []j.Code{
		j.Op("*").Id(g.structName),
		j.Error(),
	}

	getArgs := []j.Code{
		j.Lit(g.baseName),
	}

	if g.requiredAppID {
		getArgs = append(getArgs, j.Id("appID"))
	} else {
		getArgs = append(getArgs, j.Lit(0))
	}

	body := []j.Code{
		j.List(j.Id("si"), j.Err()).Op(":=").Id(g.schemaVarName).Dot("Get").Call(getArgs...),
		j.Line(),
		jenIfErrRetNilErr(),
		j.Line(),
		j.Id("s").Op(":=").Op("&").Id(g.structName).Values(j.Dict{
			j.Id("Client"):    j.Id("c"),
			j.Id("Interface"): j.Id("si"),
		}),
		j.Line(),
		j.Return(j.Id("s"), j.Nil()),
	}

	code := j.Null()

	for i, c := range comments {
		code.Comment(c).Line()

		if i != len(comments)-1 {
			code.Comment("").Line()
		}
	}

	return code.
		Func().
		Id(g.structCtorName).
		Params(params...).
		Params(retTypes...).
		Block(body...)
}

func (g *APIGen) genStructGetter() j.Code {
	comments := []string{
		fmt.Sprintf(commentfStructGetter, g.structName, g.structName),
	}

	getterReceiver := j.Id("c").Add(g.jenUnqualiClientPtr())
	getterParams := []j.Code{}
	ctorParams := []j.Code{j.Id("c")}

	if g.requiredAppID {
		getterParams = append(getterParams, j.Id("appID").Uint32())
		ctorParams = append(ctorParams, j.Id("appID"))
		comments = append(comments, fmt.Sprintf(commentfSupportedAppIDs, g.appIDs))
	}

	retTypes := []j.Code{
		j.Op("*").Id(g.structName),
		j.Error(),
	}

	fnBody := []j.Code{
		j.Return(j.Id(g.structCtorName).Call(ctorParams...)),
	}

	code := j.Null()

	for i, c := range comments {
		code.Comment(c).Line()

		if i != len(comments)-1 {
			code.Comment("").Line()
		}
	}

	return code.
		Func().
		Parens(getterReceiver).
		Id(g.structName).
		Params(getterParams...).
		Params(retTypes...).
		Block(fnBody...)
}

func (g *APIGen) methodFuncName(methodName string) string {
	if methodName[0] >= 'a' && methodName[0] <= 'z' {
		return xstrings.ToCamelCase(methodName)
	}

	return methodName
}

func (g *APIGen) methodResultStructName(methodName string) string {
	return g.structName + g.methodFuncName(methodName)
}

func (g *APIGen) genMethod(methodName string, sms *geyser.SchemaMethods) (j.Code, error) {
	versions, err := sms.Versions()

	if err != nil {
		return nil, err
	}

	funcName := g.methodFuncName(methodName)
	resultStructName := g.methodResultStructName(methodName)
	requiredVersion := len(versions) > 1

	comments := []string{
		fmt.Sprintf(commentfStructMethodHeader, funcName, methodName),
	}

	if requiredVersion {
		comments = append(comments, fmt.Sprintf(commentfSupportedVersions, versions))
	}

	structReceiver := j.Id("i").Op("*").Id(g.structName)

	params := []j.Code{}

	if requiredVersion {
		params = append(params, j.Id("version").Int())
	}

	retTypes := j.List(
		g.jenRequestPtr(),
		j.Error(),
	)

	var getParamsLast j.Code

	if requiredVersion {
		getParamsLast = j.Id("version")
	} else {
		getParamsLast = j.Lit(versions[0])
	}

	getParams := []j.Code{j.Lit(methodName), getParamsLast}

	reqInst := j.Id("req").Op(":=").Add(g.jenRequestAddr()).Values(j.Dict{
		j.Id("Client"):    j.Id("i").Dot("Client"),
		j.Id("Interface"): j.Id("i").Dot("Interface"),
		j.Id("Method"):    j.Id("sm"),
		j.Id("Result"):    j.Op("&").Id(resultStructName).Values(),
	})

	body := []j.Code{
		j.List(j.Id("sm"), j.Err()).Op(":=").Id("i").Dot("Interface").Dot("Methods").Dot("Get").Call(getParams...),
		j.Line(),
		jenIfErrRetNilErr(),
		j.Line(),
		reqInst,
		j.Line(),
		j.Return(j.Id("req"), j.Nil()),
	}

	code := j.Null()

	for i, c := range comments {
		code.Comment(c).Line()

		if i != len(comments)-1 {
			code.Comment("").Line()
		}
	}

	code.Func().Parens(structReceiver).Id(funcName).Params(params...).Parens(retTypes).Block(body...)

	return code, nil
}

func (g *APIGen) genMethods() (j.Code, error) {
	code := j.Null()

	for name, group := range g.groupedMethods {
		method, err := g.genMethod(name, group)

		if err != nil {
			return nil, err
		}

		code.Line().Add(method)
	}

	return code, nil
}

func (g *APIGen) genResult(methodName string) j.Code {
	resultStructName := g.methodResultStructName(methodName)
	comment := fmt.Sprintf(commentfStructResult, resultStructName, g.baseName, methodName)

	return j.
		Comment(comment).
		Line().
		Type().
		Id(resultStructName).
		Struct()
}

func (g *APIGen) genResults() j.Code {
	code := j.Null()

	for name := range g.groupedMethods {
		result := g.genResult(name)
		code.Line().Add(result)
	}

	return code
}

func (g *APIGen) genInterfaceFile() (*j.File, error) {
	f := jenFile(g.pkgName)

	f.HeaderComment(commentDisclaimer)
	f.HeaderComment(fmt.Sprintf(commentfDisclaimerInterface, g.baseName))

	schemaDecl, err := g.genSchemaDecl()

	if err != nil {
		return nil, err
	}

	f.Add(schemaDecl)
	f.Add(g.genStructDef())
	f.Add(g.genStructCtor())
	f.Add(g.genStructGetter())

	methods, err := g.genMethods()

	if err != nil {
		return nil, err
	}

	f.Add(methods)

	return f, nil
}

func (g *APIGen) genResultsFile() (*j.File, error) {
	f := jenFile(g.pkgName)

	f.HeaderComment(commentDisclaimer)
	f.Add(g.genResults())

	return f, nil
}

func (g *APIGen) GenerateInterfaceFile() (string, EGenerated, error) {
	etest, err := g.interfaceFile.Update(g.genInterfaceFile)
	return g.interfaceFile.Filename(), etest, err
}

func (g *APIGen) GenerateResultsFile() (string, EGenerated, error) {
	etest, err := g.resultsFile.Update(g.genResultsFile)
	return g.resultsFile.Filename(), etest, err
}

func (g *APIGen) RemoveInterfaceFile() (string, EGenerated, error) {
	etest, err := g.interfaceFile.Remove()
	return g.interfaceFile.Filename(), etest, err
}

func (g *APIGen) RemoveResultsFile() (string, EGenerated, error) {
	etest, err := g.resultsFile.Remove()
	return g.resultsFile.Filename(), etest, err
}
